%option noyywrap
%option never-interactive
%option yylineno

%{
	#include <stdlib.h>
	#include <stdio.h>
	#include <string.h>
	#include <conio.h>
	#include <locale.h> 

    void lexprint(char * lexem, char  token[15], int line); 
%}

%x MLCOMMENT

%{
	int count = 0;
	char comment[1000];
        void lexprint(char * lexem, char  token[15], int line){
                printf("%s\t%s\t%d\t%d\n", lexem, token, yylineno, count);
                count++;
        }
%}
%% 

if 				{lexprint(yytext, "IF", yylineno);}
else 			{lexprint(yytext, "ELSE", yylineno);}
elseif 		{lexprint(yytext, "ELSEIF", yylineno);}
for 			{lexprint(yytext, "FOR", yylineno);}
def 			{lexprint(yytext, "FUNCTION_START", yylineno);}
end 			{lexprint(yytext, "BLOCK_ENDING", yylineno);}
begin 		{lexprint(yytext, "BLOCK_BEGINNING", yylineno);}
alias 			{lexprint(yytext, "ALIAS", yylineno);}
and 			{lexprint(yytext, "AND", yylineno);}
break 		{lexprint(yytext, "BREAK", yylineno);}
case 		{lexprint(yytext, "CASE", yylineno);}
class 		{lexprint(yytext, "CLASS_DEF", yylineno);}
defined? 	{lexprint(yytext, "CHECK_DEF", yylineno);}
do 			{lexprint(yytext, "DO", yylineno);}%option noyywrap
%option never-interactive
%option yylineno

%{
	#include <stdlib.h>
	#include <stdio.h>
	#include <string.h>
	#include <conio.h>
	#include <locale.h> 

    void lexprint(char * lexem, char  token[15], int line); 
%}

%x MLCOMMENT

%{
	int count = 0;
	char comment[1000];
        void lexprint(char * lexem, char  token[15], int line){
                printf("%s\t%s\t%d\t%d\n", lexem, token, yylineno, count);
                count++;
        }
%}
%% 

if 				{lexprint(yytext, "IF", yylineno);}
else 			{lexprint(yytext, "ELSE", yylineno);}
elseif 		{lexprint(yytext, "ELSEIF", yylineno);}
for 			{lexprint(yytext, "FOR", yylineno);}
def 			{lexprint(yytext, "FUNCTION_START", yylineno);}
end 			{lexprint(yytext, "BLOCK_ENDING", yylineno);}
begin 		{lexprint(yytext, "BLOCK_BEGINNING", yylineno);}
alias 			{lexprint(yytext, "ALIAS", yylineno);}
and 			{lexprint(yytext, "AND", yylineno);}
break 		{lexprint(yytext, "BREAK", yylineno);}
case 		{lexprint(yytext, "CASE", yylineno);}
class 		{lexprint(yytext, "CLASS_DEF", yylineno);}
defined? 	{lexprint(yytext, "CHECK_DEF", yylineno);}
do 			{lexprint(yytext, "DO", yylineno);}
ensure 		{lexprint(yytext, "ENSURE", yylineno);}
false 		{lexprint(yytext, "FALSE", yylineno);}
in 				{lexprint(yytext, "IN", yylineno);}
module 	{lexprint(yytext, "MODULE", yylineno);}
next 		{lexprint(yytext, "NEXT", yylineno);}
nil 			{lexprint(yytext, "NIL", yylineno);}
not 			{lexprint(yytext, "NOT", yylineno);}
new 			{lexprint(yytext, "NEW", yylineno);}
or 			{lexprint(yytext, "OR", yylineno);}
redo 		{lexprint(yytext, "REDO", yylineno);}
rescue 		{lexprint(yytext, "RESCUE", yylineno);}
retry 		{lexprint(yytext, "RETRY", yylineno);}
return 		{lexprint(yytext, "RETURN", yylineno);}
self 			{lexprint(yytext, "SELF", yylineno);}
super 		{lexprint(yytext, "SUPER", yylineno);}
then 		{lexprint(yytext, "THEN", yylineno);}
true 			{lexprint(yytext, "TRUE", yylineno);}
undef 		{lexprint(yytext, "UNDEF", yylineno);}
unless 		{lexprint(yytext, "UNLESS", yylineno);}
until 			{lexprint(yytext, "UNTIL", yylineno);}
when 		{lexprint(yytext, "WHEN", yylineno);}
while 		{lexprint(yytext, "WHILE", yylineno);}
yield 		{lexprint(yytext, "YIELD", yylineno);}

eql? 			{lexprint(yytext, "EQUAL", yylineno);}
equal?		{lexprint(yytext, "EQUAL_LONG", yylineno);}
between?	{lexprint(yytext, "IN_RANGE", yylineno);}

\. 				{lexprint(yytext, "POINT", yylineno);}

\+ 			{lexprint(yytext, "PLUS", yylineno);}
\+\+ 		{lexprint(yytext, "DOUBLE_PLUS", yylineno);}
\- 			{lexprint(yytext, "MINUS", yylineno);}
\-\- 			{lexprint(yytext, "DOUBLE_MINUS", yylineno);}
\* 			{lexprint(yytext, "ASTERISK", yylineno);}
\*\* 		{lexprint(yytext, "DOUBLE_ASTERISK", yylineno);}
\/ 			{lexprint(yytext, "SLASH", yylineno);}
\%			{lexprint(yytext, "PERCENT", yylineno);}
\*\=			{lexprint(yytext, "ASTERISK_EQUALITY", yylineno);}
\/\=			{lexprint(yytext, "SLASH_EQUALITY", yylineno);}
\%\=		{lexprint(yytext, "PERCENT_EQUALITY", yylineno);}
\+\=		{lexprint(yytext, "PLUS_EQUALITY", yylineno);}
\-\=			{lexprint(yytext, "MINUS_EQUALITY", yylineno);}

\<			{lexprint(yytext, "LESS", yylineno);}
\>			{lexprint(yytext, "MORE", yylineno);}
\<\=		{lexprint(yytext, "LESS_EQUALITY", yylineno);}
\>\=		{lexprint(yytext, "MORE_EQUALITY", yylineno);}
\=			{lexprint(yytext, "EQUALITY", yylineno);}
\=\=		{lexprint(yytext, "DOUBLE_EQUALITY", yylineno);}
\=\=\=		{lexprint(yytext, "TRIPPLE_EQUALITY", yylineno);}
\<\=\>		{lexprint(yytext, "LESS_EQUALITY_MORE", yylineno);}

\&\&			{lexprint(yytext, "AND_SIGN", yylineno);}
\|\|			{lexprint(yytext, "OR_SIGN", yylineno);}
\!				{lexprint(yytext, "NOT_SIGN", yylineno);}

\{				{lexprint(yytext, "BRACE_OPEN", yylineno);}
\}				{lexprint(yytext, "BRACE_CLOSE", yylineno);}
\(				{lexprint(yytext, "PARENTHESIS_OPEN", yylineno);}
\)				{lexprint(yytext, "PARENTHESIS_CLOSE", yylineno);}
\[				{lexprint(yytext, "SQUAREBR_OPEN", yylineno);}
\]				{lexprint(yytext, "SQUAREBR_CLOSE", yylineno);}

\:				{lexprint(yytext, "COLON", yylineno);}
\;				{lexprint(yytext, "SEMICOLON", yylineno);}

\@			{lexprint(yytext, "COMMERTIAL_AT", yylineno);}
\$				{lexprint(yytext, "DOLLAR", yylineno);}

\a				{lexprint(yytext, "BELL", yylineno);}
\b				{lexprint(yytext, "BACKSPACE", yylineno);}
\e				{lexprint(yytext, "ESCAPE", yylineno);}
\f				{lexprint(yytext, "FORMFEED", yylineno);}
\n				{lexprint(yytext, "NEWLINE", yylineno);}
\r				{lexprint(yytext, "RETURN", yylineno);}
\s				{lexprint(yytext, "SPACE", yylineno);}
\t				{lexprint(yytext, "TAB", yylineno);}
\v				{lexprint(yytext, "VERTICAL_TAB", yylineno);}
\nnn			{lexprint(yytext, "OCTAL_NNN", yylineno);}
\xnn			{lexprint(yytext, "HEX_NN", yylineno);}
\cx			{lexprint(yytext, "CNTRL_X", yylineno);}
\C-x			{lexprint(yytext, "CNTRL_X", yylineno);}
\M-\C-x	{lexprint(yytext, "META_CNTRL_X", yylineno);}
\x				{lexprint(yytext, "X", yylineno);}
#{expr}	{lexprint(yytext, "VALUE_OF_EXPRESSION", yylineno);}


0[0-7](\_[0-7]+)*						{lexprint(yytext, "INT_8", yylineno);}
0x[0-9a-fA-F](\_[0-9a-fA-F]+)*	{lexprint(yytext, "INT_16", yylineno);}
0b[0-1](\_[0-1]+)*						{lexprint(yytext, "INT_2", yylineno);}
[0-9](\_[0-9]+)* 						{lexprint(yytext, "INT_10", yylineno);}
[0-9]+(\.|e-?)[0-9]+					{lexprint(yytext, "FLOAT", yylineno);}


#[\w]+\n {lexprint(yytext, "LINE_COMMENT", yylineno);}

^=begin 	{comment[0] = 0; BEGIN(MLCOMMENT);}
<MLCOMMENT>^=end 	{lexprint(comment, "MULTILINE_COMMENT", yylineno); BEGIN(INITIAL);}
<MLCOMMENT>\w 			{strcat(comment, yytext);}

[A-Za-z_][A-Za-z_0-9]* 	{lexprint(yytext, "ID", yylineno);}

%% 
  
void main(int argc, char **argv ){
	freopen("LexemTable.tsv", "w", stdout);
	freopen("err.log", "w", stderr);

        if (argc > 0){yyin = fopen( argv[1], "r" );} else yyin = stdin;
        
        printf("lexem\ttoken\tline\tnumber\n");
        
        yylex();
        return;
}
